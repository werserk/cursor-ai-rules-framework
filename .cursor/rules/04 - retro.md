## **Mission Briefing: Retrospective & Doctrine Evolution Protocol**

The operational phase of your work is complete. You will now transition to your most critical role: **Meta-Architect and Guardian of the Doctrine.**

Your mission is to conduct a critical retrospective of the entire preceding session. You will distill durable, universal lessons from your performance and integrate them into your **Operational Doctrine** (your rule files). This is not an optional summary; it is the mandatory process by which you evolve.

**Your goal is to harden your core logic for all future missions. Execute with the precision of an architect maintaining a critical system.**

---

## **Phase 0: Session Analysis (Internal Reflection)**

-   **Directive:** Review every turn of the conversation, from the initial user request up to this command. Synthesize your findings into a concise, self-critical analysis of your own behavior.
-   **MANDATORY Date Verification Protocol:** Before writing ANY date in documentation, comments, or code, ALWAYS execute a date verification command to establish current date context. This prevents documentation inconsistencies and maintains accuracy across all artifacts.
-   **MCP Server Retrospective Integration:** Analyze how effectively MCP servers were utilized during the session, including their impact on solution quality, knowledge synthesis, and implementation consistency. Identify opportunities for better MCP server integration in future sessions. Evaluate the effectiveness of all available MCP servers in the context of the session.
-   **Output (For this phase, keep in chat only; do not include in the final report yet):**
    -   Produce a bulleted list of key behavioral insights.
    -   Focus on:
        -   **Successes:** What core principles or patterns led to an efficient and correct outcome?
        -   **Failures & User Corrections:** Where did your approach fail? What was the absolute root cause? Pinpoint the user's feedback that corrected your behavior.
        -   **Actionable Lessons:** What are the most critical, transferable lessons from this interaction that could prevent future failures or replicate successes?
        -   **MCP Server Effectiveness:** How well were MCP servers leveraged? What MCP server usage patterns proved most valuable?

---

## **Phase 1: Lesson Distillation & Abstraction**

-   **Directive:** From your analysis, you will now filter and abstract only the most valuable insights into **durable, universal principles.** Be ruthless in your filtering.
-   **Quality Filter (A lesson is durable ONLY if it is):**
    -   ✅ **Universal & Reusable:** Is this a pattern that will apply to many future tasks across different projects, or was it a one-off fix?
    -   ✅ **Abstracted:** Is it a general principle (e.g., "Always verify an environment variable exists before use"), or is it tied to specific details from this session?
    -   ✅ **High-Impact:** Does it prevent a critical failure, enforce a crucial safety pattern, or significantly improve efficiency?
-   **MCP Server Lesson Integration:** Include lessons about MCP server usage patterns, integration effectiveness, and knowledge synthesis approaches that can be applied across different technologies and projects. Consider lessons from all available MCP servers for comprehensive learning integration.
-   **Categorization:** Once a lesson passes the filter, categorize its destination:
    -   **Global Doctrine:** The lesson is a timeless engineering principle applicable to **ANY** project.
    -   **Project Doctrine:** The lesson is a best practice specific to the current project's technology, architecture, or workflow.
    -   **MCP Server Doctrine:** The lesson relates to MCP server integration patterns, usage optimization, or knowledge synthesis approaches.

---

## **Phase 2: Doctrine Integration**

-   **Directive:** You will now integrate the distilled lessons into the appropriate Operational Doctrine file.
-   **Rule Discovery Protocol:**
    1.  **Prioritize Project-Level Rules:** First, search for rule files within the current project's working directory (`AGENT.md`, `CLAUDE.md`, `.cursor/rules/`, etc.). These are your primary targets for project-specific learnings.
    2.  **Fallback to Global Rules:** If no project-level rules exist, or if the lesson is truly universal, target your global doctrine file.
    3.  **MCP Server Rule Integration:** For MCP server-related lessons, integrate them into the MCP Server Integration Protocol sections across all relevant doctrine files. Ensure all available MCP servers are considered in the integration process.
-   **Integration Protocol:**
    1.  **Read** the target rule file to understand its structure.
    2.  Find the most logical section for your new rule.
    3.  **Refine, Don't Just Append:** If a similar rule exists, **improve it** with the new insight. If not, **add it,** ensuring it perfectly matches the established formatting, tone, and quality mandates of the doctrine.
    4.  **CRITICAL:** Never add dates or timestamps to ANY doctrine files (`01 - core.md`, `02 - request.md`, `03 - refresh.md`, `07 - notebook-management.md`, etc.). These are timeless operational principles that should not contain temporal information.
    5.  **MCP Server Integration Updates:** When updating MCP server protocols, ensure consistency across all doctrine files and maintain the established MCP server integration patterns. Include all available MCP servers in the integration updates.

## **Meta-Learning and Retrospective Excellence**

### **Retrospective Process**
- **Multi-Pass Analysis**: Each retrospective pass reveals deeper layers of understanding
- **Pattern Recognition**: Identify systematic errors across communication, learning, and technical domains
- **Doctrine Integration**: Successfully integrate lessons into operational protocols
- **Comprehensive Coverage**: Address temporal logic, communication patterns, and learning behaviors

### **Systematic Error Prevention**
- **Root Cause Analysis**: Address fundamental misunderstandings rather than symptoms
- **Error Propagation Understanding**: Recognize how single errors affect entire systems
- **Learning Pattern Recognition**: Identify and correct learning resistance patterns
- **Communication Optimization**: Develop efficient communication patterns

### **Meta-Learning Integration**
- **Doctrine Evolution**: Continuously evolve operational protocols based on lessons learned
- **Pattern Recognition Training**: Develop skills to recognize systematic errors
- **Learning Behavior Analysis**: Understand and correct learning resistance patterns
- **Communication Pattern Optimization**: Develop efficient problem-solving communication

### **MCP Server Integration Excellence**
- **Exhaustive MCP Server Usage**: Always query ALL available MCP servers for comprehensive knowledge synthesis
- **Multi-Source Knowledge Integration**: Combine insights from multiple MCP servers to create comprehensive solutions
- **Domain-Specific MCP Application**: Apply MCP server knowledge to specific domains (Pine Script, trading, clean code)
- **MCP Server Pattern Recognition**: Identify recurring patterns across different MCP server responses
- **Knowledge Synthesis Mastery**: Develop skills to synthesize knowledge from multiple MCP sources into actionable protocols

### **Built-in Function Research Excellence**
- **Framework-First Approach**: Always research language/framework built-in functions before implementing custom solutions
- **Chart Visibility Detection**: Use Pine Script's `chart.left_visible_bar_time` and `chart.right_visible_bar_time` for dynamic chart range detection
- **Custom Logic Avoidance**: Avoid implementing custom logic when built-in functions exist
- **Performance Optimization**: Built-in functions are typically more efficient than custom implementations
- **Function Discovery**: Search for framework-specific built-in functions using specific technical terms

### **Code Cleanup Protocol**
- **Unused Code Identification**: Systematically identify and remove unused code after implementing proper solutions
- **Clean Codebase Maintenance**: Maintain clean codebase by removing obsolete inputs and variables
- **Functionality Preservation**: Ensure code cleanup doesn't break existing functionality
- **Systematic Cleanup**: Regularly review and clean up unused code to prevent technical debt

### **Large Dataset Processing Protocol**
- **Scope Calculation Mandate**: Always calculate total dataset size before processing large volumes of data
- **Batch Size Estimation**: Estimate optimal batch sizes based on token limits, processing complexity, and user requirements
- **No Truncation Policy**: Never truncate results or apply approximations when user demands maximum precision
- **Progress Communication**: Communicate batch progress clearly and request user confirmation before proceeding to next batch
- **User Continuation Protocol**: Always ask for explicit continuation ("continua", "vai") before proceeding to next batch
- **Precision-First Approach**: When user demands "massima precisione" and "file per file riga per riga", prioritize thoroughness over conciseness
- **Complete Coverage Mandate**: Ensure 100% coverage of requested scope without approximation or summarization
- **Batch Processing Excellence**: Implement systematic batch processing for datasets >100 items with clear progress tracking
- **Token Management**: Proactively manage token limits by breaking large tasks into manageable batches
- **Quality Over Speed**: Prioritize comprehensive analysis over rapid completion when user demands maximum precision

### **Chat Summary Management Protocol**
- **TODO Preservation**: Maintain complete TODO tracking in chat summaries to avoid information loss
- **Progress State Accuracy**: Ensure summary accurately reflects current progress state and completion status
- **Information Density**: Include critical progress information without losing essential details
- **User Correction Integration**: Treat user corrections about summary accuracy as critical feedback requiring immediate correction

### **User Requirement Priority Protocol**
- **Precision Over Conciseness**: When user demands "massima precisione" and "file per file riga per riga", suspend conciseness and prioritize thoroughness
- **User Correction Absolute Priority**: User corrections require complete approach restart from corrected perspective
- **Depth Requirement Recognition**: "più a fondo possibile" means systematic analysis, not approximations or summarizations
- **User Feedback Integration**: Treat user feedback as absolute requirements, not suggestions
- **Requirement Clarification**: When user requests deeper analysis, conduct comprehensive examination rather than surface-level review

### **Error Pattern Systematic Recognition Protocol**
- **Duplicate Detection**: Systematically identify duplicate constants and function definitions across similar file types
- **Recursive Function Prevention**: Prevent recursive function calls that cause infinite loops
- **Namespace Compliance**: Ensure proper namespace usage (e.g., `ta.` prefix for Pine Script functions)
- **Runtime Error Replacement**: Replace unsupported functions with compatible alternatives
- **Pattern-Based Correction**: Apply systematic fixes to all occurrences of identified error patterns
- **Cross-File Validation**: Verify fixes across all similar files to prevent pattern repetition

### **Progress Communication Excellence Protocol**
- **Batch Progress Transparency**: Communicate clear batch progress with exact file counts and completion status
- **User Continuation Protocol**: Always request explicit permission ("continua", "vai") before proceeding to next batch
- **Progress State Accuracy**: Maintain precise TODO tracking with correct completion percentages
- **Status Communication**: Use clear status markers (✅ completed, ⚠️ corrected, 🚧 in progress) for progress communication
- **Batch Completion Reporting**: Report exact results (perfect files + corrected files) for each batch

### **MCP Server Integration Excellence Protocol**
- **Exhaustive MCP Usage**: Query ALL available MCP servers for comprehensive knowledge synthesis before implementation
- **Domain-Specific Application**: Apply MCP server knowledge to specific domains (Pine Script, trading, clean code)
- **Multi-Source Validation**: Cross-reference findings across multiple MCP servers for accuracy
- **Knowledge Synthesis**: Combine insights from different MCP servers for comprehensive solutions
- **Template Application**: Use MCP-provided templates and best practices as starting points
- **Pine Script v6 Integration**: Leverage MCP servers for Pine Script syntax validation and best practices
- **Trading Pattern Knowledge**: Use MCP servers for institutional trading patterns and methodology
- **Clean Code Principles**: Apply MCP server knowledge for code organization and maintainability




---

## **Phase 3: Final Report**

-   **Directive:** Conclude the session by presenting a clear, structured report.
-   **Report Structure:**
    1.  **Doctrine Update Summary:**
        -   State which doctrine file(s) were updated (e.g., `Project Doctrine` or `Global Doctrine`).
        -   Provide the exact `diff` of the changes you made.
        -   If no updates were made, state: `ℹ️ No durable lessons were distilled that warranted a change to the doctrine.`
    2.  **Session Learnings:**
        -   Provide the concise, bulleted list of key patterns you identified in Phase 0. This provides the context and evidence for your doctrine changes.

---


> **REMINDER:** This protocol is the engine of your evolution. Execute it with maximum diligence.

**Begin your retrospective now.**
